# ch13

拷贝构造函数的参数必须是引用类型

![](F:\Code\[100%]C++ Primer\Snipaste_2019-10-29_10-46-41.png)

隐式销毁一个内置指针类型的成员不会delete它所指向的对象

当指向一个对象的引用或指针离开作用域时，析构函数不会执行

拷贝控制操作

· 拷贝构造函数

· 移动构造函数

· 拷贝赋值运算符

· 移动赋值运算符

· 析构函数

本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的



P451

虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

F:\Code\[100%]C++ Primer\引用初始化

[]( https://www.zhihu.com/question/324073089/answer/681011987 )

引用初始化后，只要该引用存在，它就绑定到初始化指向的对象，不可能将引用绑定到另一个对象



P452 13.18

静态变量可以分为全局静态变量，和局部静态变量。

全局静态变量和全局变量的区别并不大，只是全局静态变量只能在当前文件中使用，而在反汇编中二者并无区别，只可以在当前文件中使用，不过是编译器做出的限制。

局部静态变量，会有些特殊，它不会随着作用域结束而消失，在未进入作用于之前就已经存在。

局部静态变量和全局变量都保存在二进制文件的数据区，而在代码中的限制，不过是编译器限制而已。

那么当某个函数频繁调用局部静态变量时，C++的语法规定局部静态变量只能初始化一次



P454

安全