# 	ch06 函数

## 6.1.1 局部对象

如果局部静态变量没有显式初始值，将执行值初始化，内置类型的局部静态变量初始化为0。

## 6.2 参数传递

如果形参是引用类型，它将绑定到对应的实参上；否则将实参的值拷贝后赋给形参。

## 6.2.2 传引用参数

```c++
#include <iostream>
using namespace std;
auto findChar(const string& s, char c, decltype(s.size()) &occurs)
{
	auto ret = s.size();
	occurs = 0;
	for (decltype(ret)i = 0; i != s.size(); ++i)
	{
		if (s[i] == c)
		{
			
			if (ret == s.size())
			{
				ret = i;
			}
			++occurs;
		}
	}
	cout << occurs << endl;  // 4
	return ret;
}
int main()
{
	string s = "thhllhhop";
	char c = 'h';
	decltype(s.size()) occurs = 10;
	cout << findChar(s, c, occurs) << " " << occurs << endl;  // 1 10
}
```

传引用参数发现 *occurs* 的值未发生改变，后经思索，将代码改成以下形式。

```c++
auto t = findChar(s, c, occurs);
cout << t << " " << occurs << endl;  // 1 4
```

结果符合预期，说明在一条语句中修改了对象的值，会对该语句中其它调用该对象的部分造成未定义的错误。

## 6.2.3 const 形参和实参

在主函数看来调用其它函数时，其它函数的形参有没有顶层 *const* 没有区别，用实参初始化形参时会忽略掉顶层 *const*，传给它常量对象或者非常量对象都是可以的。

![ch07 p248](./Snipaste_2019-03-04_09-40-28.png)

尽量使用常量引用，普通引用类型容易给使用者误导，即允许修改实参的内容，限制了该函数所能接受的实参类型，无法把 *const* 对象、字面值常量或者需要类型转换的对象传递给普通的引用形参。

## 6.2.4 数组形参

```c++
f(int &arr[10]);  // error 将arr声明成了引用的数组
```

![](F:\Code\C++ Primer\Snipaste_2019-02-17_10-12-37.png)

```c++
f(int (&arr)[10]);  // true arr是具有10个整数的整型数组的引用
```

```c++
void print(int (*matrix)[10]);
void print(int matrix[][10]);
```

两者等价，均为指向含有10个整数的数组的指针

## 6.3.2 有返回值函数

调用一个返回引用的函数得到左值，其他返回类型得到右值，可以像使用其他左值来使用返回引用的函数调用，我们能为返回类型是非常量引用的函数的结果赋值。

## 6.4 函数重载

顶层 *const* 不影响传入函数的对象，一个拥有顶层 *const* 的形参无法和另一个没有顶层 *const* 的形参区别开

## 6.5.1 默认实参

一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

## 6.6 函数匹配

1. 选定候选函数（同名且在调用点可见）
2. 选定可行函数（实参形参数量相等且类型相同或可以相互转换）
3. 首先考虑类型相同再考虑可以类型转换的函数形参

函数形参为底层 *const* 的时候可以区别两个函数

函数形参为顶层 *const* 的时候，向实参中添加或删除 顶层 *const* 都属于精确匹配，无法区别两个函数。详情见6.53

## 6.7 函数指针

形参看上去是函数类型，实际上是按照指针看待

必须将返回类型写成指针形式，编译器不会自动将函数返回类型当成对应的指针类型处理

